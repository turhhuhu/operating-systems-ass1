void trace(int mask, int pid)
{
    struct proc* p;
    for (p = proc; p < &proc[NPROC]; p++) {
        acquire(&p->lock);
        if (p->pid == pid) {
			p -> tracemask = mask;
        }
		release(&p -> lock);
    }
}


static char* sys_names[] = {
    [SYS_fork] "fork",
    [SYS_exit] "exit",
    [SYS_wait] "wait",
    [SYS_pipe] "pipe",
    [SYS_read] "read",
    [SYS_kill] "kill",
    [SYS_exec] "exec",
    [SYS_fstat] "fstat",
    [SYS_chdir] "chdir",
    [SYS_dup] "dup",
    [SYS_getpid] "getpid",
    [SYS_sbrk] "sbrk",
    [SYS_sleep] "sleep",
    [SYS_uptime] "uptime",
    [SYS_open] "open",
    [SYS_write] "write",
    [SYS_mknod] "mknod",
    [SYS_unlink] "unlink",
    [SYS_link] "link",
    [SYS_mkdir] "mkdir",
    [SYS_close] "close",
    [SYS_trace] "trace"
};

void print_trace(int pid, int sys_num, uint64 return_value, int first_arg)
{
	switch (sys_num)
	{
	case SYS_fork:
		printf("%d: %s NULL -> %d", pid, sys_names[sys_num], return_value);
		break;
	case SYS_kill:
		printf("%d: %s %d -> %d", pid, sys_names[sys_num], first_arg, return_value);
		break;
	case SYS_sbrk:
		printf("%d: %s %d -> %d", pid, sys_names[sys_num], first_arg, return_value);
		break;
	default:
		printf("%d: %s -> %d", pid, sys_names[sys_num], return_value);
	}
}

void syscall(void)
{
    int num;
    struct proc* p = myproc();
	int first_arg;
    num = p->trapframe->a7;
	if(num == SYS_kill || num == SYS_sbrk){
		argint(0, &first_arg);
	}
    if (num > 0 && num < NELEM(syscalls) && syscalls[num]) {
        p->trapframe->a0 = syscalls[num]();
        if (num | p->tracemask == 1) {
            print_trace(p->pid, num, p->trapframe->a0, first_arg);
        }
    } else {
        printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
        p->trapframe->a0 = -1;
    }
}